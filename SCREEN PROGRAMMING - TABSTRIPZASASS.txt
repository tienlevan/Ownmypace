H**This code is automatically generated by YASH program , please do not make any changes**
CREPORT TESTER.
CCALL SCREEN 100.
CTABLES: KONA, ZQLCTKM_LOA_MAST.
CDATA: LOA_NUM LIKE ZQLCTKM_LOA_MAST-LOA_NUM.
CTYPES: BEGIN OF T_PLAN_DATA,
C         SCT_NUM LIKE ZQLCTKM_LOA_MAST-SCT_NUM,
C         REGIO_AUFT LIKE ZQLCTKM_LOA_MAST-REGIO_AUFT,
C         GUEBG LIKE ZQLCTKM_LOA_MAST-GUEBG,
C         MATNR LIKE ZQLCTKM_LOA_MAST-MATNR,
C         ZQTY_P LIKE ZQLCTKM_LOA_MAST-ZQTY_P,
C         ZVAL_P LIKE ZQLCTKM_LOA_MAST-ZVAL_P,
C         NOTE LIKE ZQLCTKM_LOA_MAST-NOTE,
C       END OF T_PLAN_DATA.
C
C*DATA:     OK_CODE LIKE SY-UCOMM.
CTYPES: BEGIN OF GET_MASTER,
C       KNUMA TYPE KONA-KNUMA,
C       VKORG TYPE KONA-VKORG,
C       VTWEG TYPE KONA-VTWEG,
C       SPART TYPE KONA-SPART,
C       BOTEXT TYPE KONA-BOTEXT,
C       DATAB TYPE KONA-DATAB,
C       DATBI TYPE KONA-DATBI,
C       ERNAM TYPE KONA-ERNAM,
C       ERDAT TYPE KONA-ERDAT,
C       ERZET TYPE KONA-ERZET,
C       AENAM TYPE KONA-AENAM,
C       AEDAT TYPE KONA-AEDAT,
C       UKNUMA TYPE KONA-UKNUMA,
C  END OF GET_MASTER.
C
CTYPES: BEGIN OF GET_FREE,
C      SCT_NUM TYPE  ZQLCTKM_LOA_MAST-SCT_NUM,
C      MATNR TYPE ZVBRP_VBRK1-MATNR,
C      ARKTX TYPE ZVBRP_VBRK1-ARKTX,
C      FKIMG TYPE ZVBRP_VBRK1-FKIMG,
C      MEINS TYPE ZVBRP_VBRK1-MEINS,
C      FKDAT TYPE ZVBRP_VBRK1-FKDAT,
C      ZBINO TYPE ZVBRP_VBRK1-ZBINO,
C      AUBEL TYPE ZVBRP_VBRK1-VBELN,
C      VBELN TYPE ZVBRP_VBRK1-VBELN,
C      REGIO_AUFT TYPE ZVBRP_VBRK1-REGIO_AUFT,
C      MATNR1 LIKE ZVBRP_VBRK1-MATNR,
C  END OF GET_FREE.
C
CTYPES: BEGIN OF GET_DIS,
C      SCT_NUM LIKE  ZQLCTKM_LOA_MAST-SCT_NUM,
C      MATNR TYPE ZVBRP_VBRK-MATNR,
C      ARKTX TYPE ZVBRP_VBRK-ARKTX,
C      MEINS TYPE ZVBRP_VBRK-MEINS,
C      FKIMG TYPE ZVBRP_VBRK-FKIMG,
C      KSCHL TYPE ZVBRP_VBRK-KSCHL,
C      KBETR TYPE ZVBRP_VBRK-KBETR,
C      KWERT TYPE ZVBRP_VBRK-KWERT,
C      ZAREA TYPE BEZEI,
C      FKDAT LIKE ZVBRP_VBRK-FKDAT,
C      ZBINO LIKE ZVBRP_VBRK-ZBINO,
C      AUBEL LIKE ZVBRP_VBRK-VBELN,
C      VBELN LIKE ZVBRP_VBRK-VBELN,
C      REGIO_AUFT LIKE ZVBRP_VBRK-REGIO_AUFT,
C  END OF GET_DIS.
C
C  DATA: GET1 TYPE GET_MASTER,
C        GET2 TYPE GET_FREE,
C        GET2T TYPE STANDARD TABLE OF GET_FREE,
C        GET3 TYPE GET_DIS,
C        GET3T TYPE STANDARD TABLE OF GET_DIS.
C
C  DATA:     G_PLAN_DATA_ITAB   TYPE T_PLAN_DATA OCCURS 0,
C            G_PLAN_DATA_WA     TYPE T_PLAN_DATA. "work area
C  DATA:     G_PLAN_DATA_COPIED.           "copy flag
C
C
C*&SPWIZARD: DECLARATION OF TABLECONTROL 'PLAN_DATA' ITSELF
CCONTROLS: PLAN_DATA TYPE TABLEVIEW USING SCREEN 0102.
C
C*&SPWIZARD: LINES OF TABLECONTROL 'PLAN_DATA'
CDATA:     G_PLAN_DATA_LINES  LIKE SY-LOOPC.
C
C
C* DECLARE TO STORE PARAMETERS
C
C DATA: DOC_DATE TYPE RANGE OF KONA-DATAB,
C       DOC_LINE LIKE LINE OF DOC_DATE.
C DATA: MATAB TYPE RANGE OF ZQLCTKM_LOA_MAST-MATNR,
C       MASTR LIKE LINE OF MATAB.
C
C*&SPWIZARD: FUNCTION CODES FOR TABSTRIP 'CLEAR_VIEWS'
CCONSTANTS: BEGIN OF C_CLEAR_VIEWS,
C             TAB1 LIKE SY-UCOMM VALUE 'CLEAR_VIEWS_FC1',
C             TAB2 LIKE SY-UCOMM VALUE 'CLEAR_VIEWS_FC2',
C             TAB3 LIKE SY-UCOMM VALUE 'CLEAR_VIEWS_FC3',
C             TAB4 LIKE SY-UCOMM VALUE 'CLEAR_VIEWS_FC4',
C           END OF C_CLEAR_VIEWS.
C*&SPWIZARD: DATA FOR TABSTRIP 'CLEAR_VIEWS'
CCONTROLS:  CLEAR_VIEWS TYPE TABSTRIP.
CDATA:      BEGIN OF G_CLEAR_VIEWS,
C             SUBSCREEN   LIKE SY-DYNNR,
C             PROG        LIKE SY-REPID VALUE 'ZASASS',
C             PRESSED_TAB LIKE SY-UCOMM VALUE C_CLEAR_VIEWS-TAB1,
C           END OF G_CLEAR_VIEWS.
CDATA:      OK_CODE LIKE SY-UCOMM.
CSTART-OF-SELECTION.
C*&SPWIZARD: OUTPUT MODULE FOR TS 'CLEAR_VIEWS'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: SETS ACTIVE TAB
CMODULE CLEAR_VIEWS_ACTIVE_TAB_SET OUTPUT.
C  CLEAR_VIEWS-ACTIVETAB = G_CLEAR_VIEWS-PRESSED_TAB.
C  CASE G_CLEAR_VIEWS-PRESSED_TAB.
C    WHEN C_CLEAR_VIEWS-TAB1.
C      G_CLEAR_VIEWS-SUBSCREEN = '0101'.
C    WHEN C_CLEAR_VIEWS-TAB2.
C      G_CLEAR_VIEWS-SUBSCREEN = '0102'.
C    WHEN C_CLEAR_VIEWS-TAB3.
C      G_CLEAR_VIEWS-SUBSCREEN = '0103'.
C    WHEN C_CLEAR_VIEWS-TAB4.
C      G_CLEAR_VIEWS-SUBSCREEN = '0104'.
C    WHEN OTHERS.
C*&SPWIZARD:      DO NOTHING
C  ENDCASE.
CENDMODULE.
C
C*&SPWIZARD: INPUT MODULE FOR TS 'CLEAR_VIEWS'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: GETS ACTIVE TAB
CMODULE CLEAR_VIEWS_ACTIVE_TAB_GET INPUT.
C  OK_CODE = SY-UCOMM.
C  CASE OK_CODE.
C    WHEN C_CLEAR_VIEWS-TAB1.
C      G_CLEAR_VIEWS-PRESSED_TAB = C_CLEAR_VIEWS-TAB1.
C    WHEN C_CLEAR_VIEWS-TAB2.
C      G_CLEAR_VIEWS-PRESSED_TAB = C_CLEAR_VIEWS-TAB2.
C    WHEN C_CLEAR_VIEWS-TAB3.
C      G_CLEAR_VIEWS-PRESSED_TAB = C_CLEAR_VIEWS-TAB3.
C    WHEN C_CLEAR_VIEWS-TAB4.
C      G_CLEAR_VIEWS-PRESSED_TAB = C_CLEAR_VIEWS-TAB4.
C    WHEN OTHERS.
C*&SPWIZARD:      DO NOTHING
C  ENDCASE.
CENDMODULE.
C*&---------------------------------------------------------------------*
C*&      Module  STATUS_0100  OUTPUT
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
CMODULE STATUS_0100 OUTPUT.
C  SET PF-STATUS 'STS01'.
C*  SET TITLEBAR 'xxx'.
C
CENDMODULE.
C
C*&---------------------------------------------------------------------*
C*&      Module  USER_COMMAND_0100  INPUT
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
CMODULE USER_COMMAND_0100 INPUT.
CCASE OK_CODE.
C    WHEN 'LEAVE' OR 'BACK' OR 'Cancel' .
C      LEAVE PROGRAM.
C    WHEN 'GETINFO' .
C* Check vaild LOA.
C     SELECT SINGLE SCT_NUM FROM ZQLCTKM_LOA_MAST INTO LOA_NUM WHERE LOA_NUM = ZQLCTKM_LOA_MAST-LOA_NUM.
C     IF SY-SUBRC = 0.
C     CLEAR LOA_NUM.
C     LOA_NUM = ZQLCTKM_LOA_MAST-LOA_NUM.
C     PERFORM GET_INFO.
C     PERFORM GET_FREE.
C     PERFORM GET_DIS.
C     ELSE.
C     CLEAR: GET1, GET2T, GET3T,G_PLAN_DATA_ITAB, LOA_NUM.
C     MESSAGE 'Please Select A Relevant LOA Number!' TYPE 'I'.
C     ENDIF.
C
C  ENDCASE.
CENDMODULE.
C
C*&---------------------------------------------------------------------*
C*&      Form  GET_INFO
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
C*  -->  p1        text
C*  <--  p2        text
C*----------------------------------------------------------------------*
CFORM GET_INFO .
C  IF LOA_NUM IS NOT INITIAL .
C    SELECT * FROM KONA INTO CORRESPONDING FIELDS OF GET1 WHERE ABREX = LOA_NUM.
C      IF GET1-UKNUMA IS INITIAL.
C         GET1-UKNUMA = GET1-KNUMA.
C         CLEAR GET1-KNUMA.
C      SELECT SINGLE KNUMA FROM KONA INTO GET1-KNUMA WHERE UKNUMA = GET1-UKNUMA.
C      ENDIF.
C      ENDSELECT.
C  ELSE.
C    MESSAGE 'PLEASE FILL RIGHT LOA NUMBER' TYPE 'E'.
C  ENDIF.
C
CENDFORM.
C*&---------------------------------------------------------------------*
C*&      Module  STATUS_0110  OUTPUT
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
CMODULE STATUS_0110 OUTPUT.
C*  SET PF-STATUS 'xxxxxxxx'.
C*  SET TITLEBAR 'xxx'.
C* Move corresponding field.
C
C      KONA-KNUMA  = GET1-KNUMA.
C      KONA-VKORG  = GET1-VKORG.
C      KONA-VTWEG  = GET1-VTWEG.
C      KONA-SPART  = GET1-SPART.
C      KONA-BOTEXT = GET1-BOTEXT.
C      KONA-DATAB  = GET1-DATAB.
C      KONA-DATBI  = GET1-DATBI.
C      KONA-ERNAM  = GET1-ERNAM.
C      KONA-ERDAT  = GET1-ERDAT.
C      KONA-ERZET  = GET1-ERZET.
C      KONA-AENAM  = GET1-AENAM.
C      KONA-AEDAT  = GET1-AEDAT.
C      KONA-UKNUMA = GET1-UKNUMA.
C
CENDMODULE.
C
C***&SPWIZARD: DATA DECLARATION FOR TABLECONTROL 'PLAN_DATA'
C*&SPWIZARD: DEFINITION OF DDIC-TABLE
C*TABLES:   .
C
C
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'PLAN_DATA'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: COPY DDIC-TABLE TO ITAB
CMODULE PLAN_DATA_INIT OUTPUT.
C*  CLEAR G_PLAN_DATA_COPIED.
C IF LOA_NUM IS NOT INITIAL.
C*&SPWIZARD: COPY DDIC-TABLE 'ZQLCTKM_LOA_MAST'
C*&SPWIZARD: INTO INTERNAL TABLE 'g_PLAN_DATA_itab'
C    SELECT * FROM ZQLCTKM_LOA_MAST
C       INTO CORRESPONDING FIELDS
C       OF TABLE G_PLAN_DATA_ITAB WHERE LOA_NUM = LOA_NUM.
C*    G_PLAN_DATA_COPIED = 'X'.
C    REFRESH CONTROL 'PLAN_DATA' FROM SCREEN '0102'.
C  ENDIF.
CENDMODULE.
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'PLAN_DATA'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: MOVE ITAB TO DYNPRO
CMODULE PLAN_DATA_MOVE OUTPUT.
C  MOVE-CORRESPONDING G_PLAN_DATA_WA TO ZQLCTKM_LOA_MAST.
CENDMODULE.
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'PLAN_DATA'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: GET LINES OF TABLECONTROL
CMODULE PLAN_DATA_GET_LINES OUTPUT.
C  G_PLAN_DATA_LINES = SY-LOOPC.
CENDMODULE.
C
C*&SPWIZARD: INPUT MODULE FOR TC 'PLAN_DATA'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: PROCESS USER COMMAND
CMODULE PLAN_DATA_USER_COMMAND INPUT.
C  OK_CODE = SY-UCOMM.
C  PERFORM USER_OK_TC USING    'PLAN_DATA'
C                              'G_PLAN_DATA_ITAB'
C                              'FLAG'
C                     CHANGING OK_CODE.
C  SY-UCOMM = OK_CODE.
CENDMODULE.
C
C*----------------------------------------------------------------------*
C*   INCLUDE TABLECONTROL_FORMS                                         *
C*----------------------------------------------------------------------*
C
C*&---------------------------------------------------------------------*
C*&      Form  USER_OK_TC                                               *
C*&---------------------------------------------------------------------*
C FORM USER_OK_TC USING    P_TC_NAME TYPE DYNFNAM
C                          P_TABLE_NAME
C                          P_MARK_NAME
C                 CHANGING P_OK      LIKE SY-UCOMM.
C
C*&SPWIZARD: BEGIN OF LOCAL DATA----------------------------------------*
C   DATA: L_OK              TYPE SY-UCOMM,
C         L_OFFSET          TYPE I.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C*&SPWIZARD: Table control specific operations                          *
C*&SPWIZARD: evaluate TC name and operations                            *
C   SEARCH P_OK FOR P_TC_NAME.
C   IF SY-SUBRC <> 0.
C     EXIT.
C   ENDIF.
C   L_OFFSET = STRLEN( P_TC_NAME ) + 1.
C   L_OK = P_OK+L_OFFSET.
C*&SPWIZARD: execute general and TC specific operations                 *
C   CASE L_OK.
C     WHEN 'INSR'.                      "insert row
C       PERFORM FCODE_INSERT_ROW USING    P_TC_NAME
C                                         P_TABLE_NAME.
C       CLEAR P_OK.
C
C     WHEN 'DELE'.                      "delete row
C       PERFORM FCODE_DELETE_ROW USING    P_TC_NAME
C                                         P_TABLE_NAME
C                                         P_MARK_NAME.
C       CLEAR P_OK.
C
C     WHEN 'P--' OR                     "top of list
C          'P-'  OR                     "previous page
C          'P+'  OR                     "next page
C          'P++'.                       "bottom of list
C       PERFORM COMPUTE_SCROLLING_IN_TC USING P_TC_NAME
C                                             L_OK.
C       CLEAR P_OK.
C*     WHEN 'L--'.                       "total left
C*       PERFORM FCODE_TOTAL_LEFT USING P_TC_NAME.
C*
C*     WHEN 'L-'.                        "column left
C*       PERFORM FCODE_COLUMN_LEFT USING P_TC_NAME.
C*
C*     WHEN 'R+'.                        "column right
C*       PERFORM FCODE_COLUMN_RIGHT USING P_TC_NAME.
C*
C*     WHEN 'R++'.                       "total right
C*       PERFORM FCODE_TOTAL_RIGHT USING P_TC_NAME.
C*
C     WHEN 'MARK'.                      "mark all filled lines
C       PERFORM FCODE_TC_MARK_LINES USING P_TC_NAME
C                                         P_TABLE_NAME
C                                         P_MARK_NAME   .
C       CLEAR P_OK.
C
C     WHEN 'DMRK'.                      "demark all filled lines
C       PERFORM FCODE_TC_DEMARK_LINES USING P_TC_NAME
C                                           P_TABLE_NAME
C                                           P_MARK_NAME .
C       CLEAR P_OK.
C
C*     WHEN 'SASCEND'   OR
C*          'SDESCEND'.                  "sort column
C*       PERFORM FCODE_SORT_TC USING P_TC_NAME
C*                                   l_ok.
C
C   ENDCASE.
C
C ENDFORM.                              " USER_OK_TC
C
C*&---------------------------------------------------------------------*
C*&      Form  FCODE_INSERT_ROW                                         *
C*&---------------------------------------------------------------------*
C FORM FCODE_INSERT_ROW
C               USING    P_TC_NAME           TYPE DYNFNAM
C                        P_TABLE_NAME             .
C
C*&SPWIZARD: BEGIN OF LOCAL DATA----------------------------------------*
C   DATA L_LINES_NAME       LIKE FELD-NAME.
C   DATA L_SELLINE          LIKE SY-STEPL.
C   DATA L_LASTLINE         TYPE I.
C   DATA L_LINE             TYPE I.
C   DATA L_TABLE_NAME       LIKE FELD-NAME.
C   FIELD-SYMBOLS <TC>                 TYPE CXTAB_CONTROL.
C   FIELD-SYMBOLS <TABLE>              TYPE STANDARD TABLE.
C   FIELD-SYMBOLS <LINES>              TYPE I.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C   ASSIGN (P_TC_NAME) TO <TC>.
C
C*&SPWIZARD: get the table, which belongs to the tc                     *
C   CONCATENATE P_TABLE_NAME '[]' INTO L_TABLE_NAME. "table body
C   ASSIGN (L_TABLE_NAME) TO <TABLE>.                "not headerline
C
C*&SPWIZARD: get looplines of TableControl                              *
C   CONCATENATE 'G_' P_TC_NAME '_LINES' INTO L_LINES_NAME.
C   ASSIGN (L_LINES_NAME) TO <LINES>.
C
C*&SPWIZARD: get current line                                           *
C   GET CURSOR LINE L_SELLINE.
C   IF SY-SUBRC <> 0.                   " append line to table
C     L_SELLINE = <TC>-LINES + 1.
C*&SPWIZARD: set top line                                               *
C     IF L_SELLINE > <LINES>.
C       <TC>-TOP_LINE = L_SELLINE - <LINES> + 1 .
C     ELSE.
C       <TC>-TOP_LINE = 1.
C     ENDIF.
C   ELSE.                               " insert line into table
C     L_SELLINE = <TC>-TOP_LINE + L_SELLINE - 1.
C     L_LASTLINE = <TC>-TOP_LINE + <LINES> - 1.
C   ENDIF.
C*&SPWIZARD: set new cursor line                                        *
C   L_LINE = L_SELLINE - <TC>-TOP_LINE + 1.
C
C*&SPWIZARD: insert initial line                                        *
C   INSERT INITIAL LINE INTO <TABLE> INDEX L_SELLINE.
C   <TC>-LINES = <TC>-LINES + 1.
C*&SPWIZARD: set cursor                                                 *
C   SET CURSOR LINE L_LINE.
C
C ENDFORM.                              " FCODE_INSERT_ROW
C
C*&---------------------------------------------------------------------*
C*&      Form  FCODE_DELETE_ROW                                         *
C*&---------------------------------------------------------------------*
C FORM FCODE_DELETE_ROW
C               USING    P_TC_NAME           TYPE DYNFNAM
C                        P_TABLE_NAME
C                        P_MARK_NAME   .
C
C*&SPWIZARD: BEGIN OF LOCAL DATA----------------------------------------*
C   DATA L_TABLE_NAME       LIKE FELD-NAME.
C
C   FIELD-SYMBOLS <TC>         TYPE CXTAB_CONTROL.
C   FIELD-SYMBOLS <TABLE>      TYPE STANDARD TABLE.
C   FIELD-SYMBOLS <WA>.
C   FIELD-SYMBOLS <MARK_FIELD>.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C   ASSIGN (P_TC_NAME) TO <TC>.
C
C*&SPWIZARD: get the table, which belongs to the tc                     *
C   CONCATENATE P_TABLE_NAME '[]' INTO L_TABLE_NAME. "table body
C   ASSIGN (L_TABLE_NAME) TO <TABLE>.                "not headerline
C
C*&SPWIZARD: delete marked lines                                        *
C   DESCRIBE TABLE <TABLE> LINES <TC>-LINES.
C
C   LOOP AT <TABLE> ASSIGNING <WA>.
C
C*&SPWIZARD: access to the component 'FLAG' of the table header         *
C     ASSIGN COMPONENT P_MARK_NAME OF STRUCTURE <WA> TO <MARK_FIELD>.
C
C     IF <MARK_FIELD> = 'X'.
C       DELETE <TABLE> INDEX SYST-TABIX.
C       IF SY-SUBRC = 0.
C         <TC>-LINES = <TC>-LINES - 1.
C       ENDIF.
C     ENDIF.
C   ENDLOOP.
C
C ENDFORM.                              " FCODE_DELETE_ROW
C
C*&---------------------------------------------------------------------*
C*&      Form  COMPUTE_SCROLLING_IN_TC
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
C*      -->P_TC_NAME  name of tablecontrol
C*      -->P_OK       ok code
C*----------------------------------------------------------------------*
C FORM COMPUTE_SCROLLING_IN_TC USING    P_TC_NAME
C                                       P_OK.
C*&SPWIZARD: BEGIN OF LOCAL DATA----------------------------------------*
C   DATA L_TC_NEW_TOP_LINE     TYPE I.
C   DATA L_TC_NAME             LIKE FELD-NAME.
C   DATA L_TC_LINES_NAME       LIKE FELD-NAME.
C   DATA L_TC_FIELD_NAME       LIKE FELD-NAME.
C
C   FIELD-SYMBOLS <TC>         TYPE CXTAB_CONTROL.
C   FIELD-SYMBOLS <LINES>      TYPE I.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C   ASSIGN (P_TC_NAME) TO <TC>.
C*&SPWIZARD: get looplines of TableControl                              *
C   CONCATENATE 'G_' P_TC_NAME '_LINES' INTO L_TC_LINES_NAME.
C   ASSIGN (L_TC_LINES_NAME) TO <LINES>.
C
C
C*&SPWIZARD: is no line filled?                                         *
C   IF <TC>-LINES = 0.
C*&SPWIZARD: yes, ...                                                   *
C     L_TC_NEW_TOP_LINE = 1.
C   ELSE.
C*&SPWIZARD: no, ...                                                    *
C     CALL FUNCTION 'SCROLLING_IN_TABLE'
C          EXPORTING
C               ENTRY_ACT             = <TC>-TOP_LINE
C               ENTRY_FROM            = 1
C               ENTRY_TO              = <TC>-LINES
C               LAST_PAGE_FULL        = 'X'
C               LOOPS                 = <LINES>
C               OK_CODE               = P_OK
C               OVERLAPPING           = 'X'
C          IMPORTING
C               ENTRY_NEW             = L_TC_NEW_TOP_LINE
C          EXCEPTIONS
C*              NO_ENTRY_OR_PAGE_ACT  = 01
C*              NO_ENTRY_TO           = 02
C*              NO_OK_CODE_OR_PAGE_GO = 03
C               OTHERS                = 0.
C   ENDIF.
C
C*&SPWIZARD: get actual tc and column                                   *
C   GET CURSOR FIELD L_TC_FIELD_NAME
C              AREA  L_TC_NAME.
C
C   IF SYST-SUBRC = 0.
C     IF L_TC_NAME = P_TC_NAME.
C*&SPWIZARD: et actual column                                           *
C       SET CURSOR FIELD L_TC_FIELD_NAME LINE 1.
C     ENDIF.
C   ENDIF.
C
C*&SPWIZARD: set the new top line                                       *
C   <TC>-TOP_LINE = L_TC_NEW_TOP_LINE.
C
C
C ENDFORM.                              " COMPUTE_SCROLLING_IN_TC
C
C*&---------------------------------------------------------------------*
C*&      Form  FCODE_TC_MARK_LINES
C*&---------------------------------------------------------------------*
C*       marks all TableControl lines
C*----------------------------------------------------------------------*
C*      -->P_TC_NAME  name of tablecontrol
C*----------------------------------------------------------------------*
CFORM FCODE_TC_MARK_LINES USING P_TC_NAME
C                               P_TABLE_NAME
C                               P_MARK_NAME.
C*&SPWIZARD: EGIN OF LOCAL DATA-----------------------------------------*
C  DATA L_TABLE_NAME       LIKE FELD-NAME.
C
C  FIELD-SYMBOLS <TC>         TYPE CXTAB_CONTROL.
C  FIELD-SYMBOLS <TABLE>      TYPE STANDARD TABLE.
C  FIELD-SYMBOLS <WA>.
C  FIELD-SYMBOLS <MARK_FIELD>.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C  ASSIGN (P_TC_NAME) TO <TC>.
C
C*&SPWIZARD: get the table, which belongs to the tc                     *
C   CONCATENATE P_TABLE_NAME '[]' INTO L_TABLE_NAME. "table body
C   ASSIGN (L_TABLE_NAME) TO <TABLE>.                "not headerline
C
C*&SPWIZARD: mark all filled lines                                      *
C  LOOP AT <TABLE> ASSIGNING <WA>.
C
C*&SPWIZARD: access to the component 'FLAG' of the table header         *
C     ASSIGN COMPONENT P_MARK_NAME OF STRUCTURE <WA> TO <MARK_FIELD>.
C
C     <MARK_FIELD> = 'X'.
C  ENDLOOP.
CENDFORM.                                          "fcode_tc_mark_lines
C
C*&---------------------------------------------------------------------*
C*&      Form  FCODE_TC_DEMARK_LINES
C*&---------------------------------------------------------------------*
C*       demarks all TableControl lines
C*----------------------------------------------------------------------*
C*      -->P_TC_NAME  name of tablecontrol
C*----------------------------------------------------------------------*
CFORM FCODE_TC_DEMARK_LINES USING P_TC_NAME
C                                 P_TABLE_NAME
C                                 P_MARK_NAME .
C*&SPWIZARD: BEGIN OF LOCAL DATA----------------------------------------*
C  DATA L_TABLE_NAME       LIKE FELD-NAME.
C
C  FIELD-SYMBOLS <TC>         TYPE CXTAB_CONTROL.
C  FIELD-SYMBOLS <TABLE>      TYPE STANDARD TABLE.
C  FIELD-SYMBOLS <WA>.
C  FIELD-SYMBOLS <MARK_FIELD>.
C*&SPWIZARD: END OF LOCAL DATA------------------------------------------*
C
C  ASSIGN (P_TC_NAME) TO <TC>.
C
C*&SPWIZARD: get the table, which belongs to the tc                     *
C   CONCATENATE P_TABLE_NAME '[]' INTO L_TABLE_NAME. "table body
C   ASSIGN (L_TABLE_NAME) TO <TABLE>.                "not headerline
C
C*&SPWIZARD: demark all filled lines                                    *
C  LOOP AT <TABLE> ASSIGNING <WA>.
C
C*&SPWIZARD: access to the component 'FLAG' of the table header         *
C     ASSIGN COMPONENT P_MARK_NAME OF STRUCTURE <WA> TO <MARK_FIELD>.
C
C     <MARK_FIELD> = SPACE.
C  ENDLOOP.
CENDFORM.                                          "fcode_tc_mark_lines
C
C*&---------------------------------------------------------------------*
C*&      Form  GET_REAL
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
C*  -->  p1        text
C*  <--  p2        text
C*----------------------------------------------------------------------*
CFORM GET_FREE .
C
C* preparing parameters
C
C
CDOC_LINE-SIGN = 'I'.
CDOC_LINE-OPTION = 'BT'.
CDOC_LINE-LOW = GET1-DATAB.
CDOC_LINE-HIGH = GET1-DATBI.
C
CAPPEND DOC_LINE TO DOC_DATE.
C
C  "Set parameters
C DATA: G_PLANTAB   TYPE T_PLAN_DATA OCCURS 0,
C       G_PLANWA     TYPE T_PLAN_DATA. "work area
C
C  SELECT * FROM ZQLCTKM_LOA_MAST INTO CORRESPONDING FIELDS OF TABLE G_PLANTAB WHERE LOA_NUM = LOA_NUM.
C
C IF SY-SUBRC IS INITIAL.
C
C  CLEAR MATAB.
C  LOOP AT G_PLANTAB INTO G_PLANWA.
C  MASTR-SIGN = 'I'.
C  MASTR-OPTION = 'EQ'.
C  MASTR-LOW = G_PLANWA-MATNR.
C  APPEND MASTR TO MATAB.
C  ENDLOOP.
C
C* Selection
C
CSELECT * FROM ZVBRP_VBRK1 INTO CORRESPONDING FIELDS OF TABLE GET2T WHERE FKDAT IN DOC_DATE AND MATNR IN MATAB AND NETWR = 0.
C
CIF SY-SUBRC = 0.
C
CLOOP AT GET2T INTO GET2.
C* GET NAGATIVE AMOUNT
C  IF GET2-AUBEL CP '4*'.
C    GET2-FKIMG = GET2-FKIMG * -1.
C  ENDIF.
C* GET BOM MASTER
C
C  DATA: STLNR1 TYPE STPO-STLNR.
C  SELECT SINGLE STLNR FROM STPO INTO STLNR1 WHERE DATUV IN DOC_DATE AND IDNRK = GET2-MATNR.
C  SELECT SINGLE MATNR FROM MAST INTO GET2-MATNR1 WHERE STLAN = '5' AND STLNR = STLNR1. "AND STLAL = 1.
C
C* GET SCT NO.
C
C  SELECT SINGLE SCT_NUM FROM ZQLCTKM_LOA_MAST INTO GET2-SCT_NUM WHERE REGIO_AUFT = GET2-REGIO_AUFT AND MATNR = GET2-MATNR.
C  IF SY-SUBRC = 0.
C    MODIFY GET2T FROM GET2.
C  ELSE.
C    DELETE GET2T INDEX SY-TABIX.
C  ENDIF.
CENDLOOP.
C  SORT GET2T BY MATNR.
CENDIF.
CENDIF.
CENDFORM.
C
C*&SPWIZARD: DECLARATION OF TABLECONTROL 'FREE_GOODS' ITSELF
CCONTROLS: FREE_GOODS TYPE TABLEVIEW USING SCREEN 0103.
C
C*&SPWIZARD: LINES OF TABLECONTROL 'FREE_GOODS'
CDATA:     G_FREE_GOODS_LINES  LIKE SY-LOOPC.
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'FREE_GOODS'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: UPDATE LINES FOR EQUIVALENT SCROLLBAR
CMODULE FREE_GOODS_CHANGE_TC_ATTR OUTPUT.
C  DESCRIBE TABLE GET2T LINES FREE_GOODS-LINES.
CENDMODULE.
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'FREE_GOODS'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: GET LINES OF TABLECONTROL
CMODULE FREE_GOODS_GET_LINES OUTPUT.
C  G_FREE_GOODS_LINES = SY-LOOPC.
CENDMODULE.
C
C*&SPWIZARD: INPUT MODULE FOR TC 'FREE_GOODS'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: PROCESS USER COMMAND
CMODULE FREE_GOODS_USER_COMMAND INPUT.
C  OK_CODE = SY-UCOMM.
C  PERFORM USER_OK_TC USING    'FREE_GOODS'
C                              'GET2T'
C                              ' '
C                     CHANGING OK_CODE.
C  SY-UCOMM = OK_CODE.
CENDMODULE.
C
C*----------------------------------------------------------------------*
C*   INCLUDE TABLECONTROL_FORMS                                         *
C*----------------------------------------------------------------------*
C
C**&---------------------------------------------------------------------*
C*&      Form  GET_DIS
C*&---------------------------------------------------------------------*
C*       text
C*----------------------------------------------------------------------*
C*  -->  p1        text
C*  <--  p2        text
C*----------------------------------------------------------------------*
CFORM GET_DIS .
C
C* Get relevant conditions
C
CTYPES: BEGIN OF COND,
C       KSCHL TYPE KONH-KSCHL,
C       VAKEY TYPE KONH-VAKEY,
C       END OF COND.
CDATA: CONDS TYPE COND,
C      CONDT TYPE STANDARD TABLE OF COND.
C
CSELECT * FROM KONH INTO CORRESPONDING FIELDS OF TABLE CONDT WHERE DATAB IN DOC_DATE AND KNUMA_PI = GET1-UKNUMA AND KNUMA_AG = GET1-KNUMA.
C
CIF SY-SUBRC = 0.
C
C  DATA: CONDZ TYPE RANGE OF KONH-KSCHL,
C        CONDL LIKE LINE OF CONDZ.
C
C
CLOOP AT CONDT INTO CONDS.
CCONDL-SIGN = 'I'.
CCONDL-OPTION = 'EQ'.
CCONDL-LOW = CONDS-KSCHL.
CAPPEND CONDL TO CONDZ.
CENDLOOP.
C
CENDIF.
C
C* Start if selection
C
CSELECT * FROM ZVBRP_VBRK INTO CORRESPONDING FIELDS OF TABLE GET3T WHERE FKDAT IN DOC_DATE AND MATNR IN MATAB AND KNUMA_PI = GET1-UKNUMA
C  AND KNUMA_AG = GET1-KNUMA AND KSCHL IN CONDZ.
CIF SY-SUBRC = 0.
C
CLOOP AT GET3T INTO GET3.
C
C* Get relevant discount types
C
CIF GET3-MATNR NP '38*'.
C  IF GET3-KSCHL = 'ZPR0'.
C    DELETE GET3T INDEX SY-TABIX.
C    CONTINUE.
C  ENDIF.
C
CENDIF.
C
C* NEGATIVE AMOUNT
CIF GET3-AUBEL CP '4*'.
C    GET3-FKIMG = GET3-FKIMG * -1.
C  ENDIF.
C
C* Get discount rate
CGET3-KBETR = GET3-KBETR / 10.
C
C*Get region name
CSELECT SINGLE BEZEI FROM T005U INTO GET3-ZAREA WHERE SPRAS = 'EN' AND LAND1 = 'VN' AND BLAND = GET3-REGIO_AUFT.
C
C* Correct amount
CGET3-KWERT = GET3-KWERT * 100.
C
C* GET SCT NO.
C  SELECT SINGLE SCT_NUM FROM ZQLCTKM_LOA_MAST INTO GET3-SCT_NUM WHERE REGIO_AUFT = GET3-REGIO_AUFT AND MATNR = GET3-MATNR.
C  IF SY-SUBRC = 0.
C    MODIFY GET3T FROM GET3.
C  ELSE.
C    DELETE GET3T INDEX SY-TABIX.
C  ENDIF.
C
CENDLOOP.
CENDIF.
CENDFORM.
C
C*&SPWIZARD: DECLARATION OF TABLECONTROL 'DISCOUNT' ITSELF
CCONTROLS: DISCOUNT TYPE TABLEVIEW USING SCREEN 0104.
C
C*&SPWIZARD: LINES OF TABLECONTROL 'DISCOUNT'
CDATA:     G_DISCOUNT_LINES  LIKE SY-LOOPC.
C
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'DISCOUNT'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: UPDATE LINES FOR EQUIVALENT SCROLLBAR
CMODULE DISCOUNT_CHANGE_TC_ATTR OUTPUT.
C  DESCRIBE TABLE GET3T LINES DISCOUNT-LINES.
CENDMODULE.
C
C*&SPWIZARD: OUTPUT MODULE FOR TC 'DISCOUNT'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: GET LINES OF TABLECONTROL
CMODULE DISCOUNT_GET_LINES OUTPUT.
C  G_DISCOUNT_LINES = SY-LOOPC.
CENDMODULE.
C
C*&SPWIZARD: INPUT MODULE FOR TC 'DISCOUNT'. DO NOT CHANGE THIS LINE!
C*&SPWIZARD: PROCESS USER COMMAND
CMODULE DISCOUNT_USER_COMMAND INPUT.
C  OK_CODE = SY-UCOMM.
C  PERFORM USER_OK_TC USING    'DISCOUNT'
C                              'GET3T'
C                              ' '
C                     CHANGING OK_CODE.
C  SY-UCOMM = OK_CODE.
CENDMODULE.
ATEXTASSS
ASUBC1
ARSTAT
ASECU
ADEVCLASS$TMP
ALDBNAME
ATYPE
AEDTX
AFIXPTX
AUCCHECKX
ASSET
DPGMIDR3TR
DOBJECTPROG
T*%E*%I*%E00*%Error opening dataset, return code:*%       38
T*%E*%I*%I01*%Session Name*%       20
T*%E*%I*%I02*%Open session*%       30
T*%E*%I*%I03*%Insert transaction*%       25
T*%E*%I*%I04*%Close Session*%       30
T*%E*%I*%I05*%Return code =*%       13
T*%E*%I*%I06*%Error session created*%       25
T*%E*%I*%S01*%Session Name*%       25
T*%E*%I*%S02*%User*%       25
T*%E*%I*%S03*%Keep session*%       25
T*%E*%I*%S04*%Lock date*%       25
T*%E*%I*%S05*%Processing Mode*%       25
T*%E*%I*%S06*%Update Mode*%       25
T*%E*%I*%S07*%Create Session*%       25
T*%E*%I*%S08*%Call transaction*%       25
T*%E*%I*%S09*%Error sessn*%       11
T*%E*%I*%S10*%Nodata indicator*%       18
T*%E*%I*%S11*%Short log*%       13
T*%E*%R*%*%ASSS*%        4
PLANE
PSTABUTCODE*0001;CODE*STS01;MODAL*D;PFKCODE*000001;ACTCODE*000001;CTXCODE*;INT_NOTE*Status for screen 100
PFUNCODE*BACK;MODIF*;PATH*;TEXTNO*001;TEXT_NAME*;ICON_TEXT*;INFO_TEXT*;SFW_SHOWHIDE*;SFW_SWITCHID*;FUN_TEXT*Back;ICON_ID*;TEXT_TYPE*S;TYPE*
PFUNCODE*CANNCEL;MODIF*;PATH*;TEXTNO*001;TEXT_NAME*ICON_CANCEL;ICON_TEXT*;INFO_TEXT*;SFW_SHOWHIDE*;SFW_SWITCHID*;FUN_TEXT*Cancel;ICON_ID*@0W@;TEXT_TYPE*S;TYPE*
PFUNCODE*GETINFO;MODIF*;PATH*;TEXTNO*001;TEXT_NAME*ICON_START_VIEWER;ICON_TEXT*;INFO_TEXT*;SFW_SHOWHIDE*;SFW_SWITCHID*;FUN_TEXT*Get infomation!;ICON_ID*@Y2@;TEXT_TYPE*S;TYPE*
PFUNCODE*LEAVE;MODIF*;PATH*;TEXTNO*001;TEXT_NAME*;ICON_TEXT*;INFO_TEXT*;SFW_SHOWHIDE*;SFW_SWITCHID*;FUN_TEXT*Exit;ICON_ID*;TEXT_TYPE*S;TYPE*
PBUTCODE*0001;NO*01;PFK_CODE*000001;PFNO*13
PPFKFUNNO*001;PFNO*03;CODE*000001;FUNCODE*BACK
PPFKFUNNO*001;PFNO*12;CODE*000001;FUNCODE*CANNCEL
PPFKFUNNO*001;PFNO*13;CODE*000001;FUNCODE*GETINFO
PPFKFUNNO*001;PFNO*15;CODE*000001;FUNCODE*LEAVE
PSETFUNCTION*BACK;STATUS*STS01
PSETFUNCTION*CANNCEL;STATUS*STS01
PSETFUNCTION*GETINFO;STATUS*STS01
PSETFUNCTION*LEAVE;STATUS*STS01
PATRMODAL*D;NORM*;INT_NOTE*Status for screen 100;SUB_CODE*;OBJ_CODE*000001;OBJ_TYPE*A
PATRMODAL*D;NORM*;INT_NOTE*Status for screen 100;SUB_CODE*;OBJ_CODE*000001;OBJ_TYPE*P
PATRMODAL*D;NORM*;INT_NOTE*Status for screen 100;SUB_CODE*0001;OBJ_CODE*000001;OBJ_TYPE*B
PADM;000001;;000001;;;
PTRK;$TMP;PROG;ZASASS
